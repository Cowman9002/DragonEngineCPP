//http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html

const float PI = 3.1415926535897;
const float E = 2.71828182846;
const float PI_inv = 1.0 / PI;

// Diffuse

vec3 Lambertian_D(vec3 albedo)
{
	return albedo * PI_inv;
}

float Schlick_comp_F(float u, float F0, float F90)
{
	return F0 + (F90 - F0) * pow(1.0 - u, 5.0);
}

vec3 Disney_D(vec3 albedo, float NoV, float NoL, float LoH, float roughness)
{
	float F90 = 0.5 + 2.0 * roughness * LoH * LoH;
    float lightScatter = Schlick_comp_F(NoL, 1.0, F90);
    float viewScatter = Schlick_comp_F(NoV, 1.0, F90);
	//return lightScatter * viewScatter * PI_inv;
    return albedo * lightScatter * viewScatter * PI_inv;
}

// BRDF

// Normal Distribution Functions

float Gaussian_Dist(float NoH, float alpha)
{
	float gaussian = 1.0 / (alpha * 0.7978845608);
	gaussian *= pow(E, -NoH * NoH / (2 * alpha * alpha));
	return gaussian;
}

float BlinnPhong_NDF(float NoH, float alpha)
{
	float a2 = alpha * alpha;
	a2 = 1.0 / a2;

	float p1 = PI_inv * a2;
	float p2 = 2.0 * a2 - 2.0;
	
	return p1 * pow(NoH, p2);
}

float Beckmann_NDF(float NoH, float alpha)
{
	float a2 = alpha * alpha;
	a2 = 1.0 / a2;
	float NoH_inv = 1.0 / NoH;
	
	float p1 = PI_inv * a2 * pow(NoH_inv, 4.0);
	float p2 = (NoH * NoH - 1.0) / (NoH_inv * NoH_inv * a2);
	
	return pow(p1, p2);
}

float GGX_NDF(float NoH, float alpha)
{
	float a2 = alpha * alpha;
	
	float p1 = NoH * NoH * (a2 - 1.0) + 1.0;
	
	return a2 / (p1 * p1 * PI);
}

float GGX_ani_NDF(float NoH, float ToH, float BoH, vec2 alpha)
{
	// TODO
	
	return GGX_NDF(NoH, (alpha.x + alpha.y) / 2.0);
}

// Geometric Shadowing

float implicit_G(float NoL, float NoV)
{
	return NoL * NoV;
}

float Neumann_G(float NoL, float NoV)
{
	float p1 = NoL * NoV;
	float p2 = max(NoL, NoV);
	return p1 / p2;
}

float CookTorrance_section(float NoH, float NoP, float VoH)
{
	float p1 = 2.0 * NoH * NoP;
	
	return p1 / VoH;
}

float CookTorrance_G(float NoH, float NoL, float NoV, float VoH)
{
	float p1 = CookTorrance_section(NoH, NoV, VoH);
	float p2 = CookTorrance_section(NoH, NoL, VoH);
	
	return min(1.0, min(p1, p2));
}

float Kelemen_G(float NoL, float NoV, float VoH)
{
	float VoH2 = VoH * VoH;
	
	return NoL * NoV / VoH2;
}

float Smith_G(float S1, float S2)
{
	return S1 * S2;
}

// Smith Components for use with above Smith_G's S1 and S2
// NoP should be one of NoL or NoV
float Beckmann_S(float NoP, float alpha)
{
	float p1 = alpha * sqrt(1.0 - NoP * NoP);
	float c = NoP / p1;
	float c2 = c * c;
	
	if(c < 1.6)
	{
		float p2 = 3.535 * c + 2.181 * c2;
		float p3 = 1.0 + 2.276 * c + 2.577 * c2;
		
		return p2 / p3;
	}
	else
	{
		return 1.0;
	}
}

float GGX_S(float NoP, float alpha)
{
	float a2 = alpha * alpha;
	
	float p1 = 2 * NoP;
	float p2 = sqrt(a2 + NoP * NoP * (1.0 - a2));
	
	return p1 / (NoP + p2);
}

float SchlickBeckmann_S(float NoP, float alpha)
{
	//float k = alpha * sqrt(2.0 / PI);
	float k = alpha * 0.7978845608;
	
	float p1 = NoP * (1 - k) + k;
	
	return NoP / p1;
}

float SchlickGGX_S(float NoP, float alpha)
{
	float k = alpha / 2.0;
	
	float p1 = NoP * (1 - k) + k;
	
	return NoP / p1;
}

// Fresnel

vec3 Schlick_F(vec3 F0, float VoH)
{
	return F0 + (1.0 - F0) * pow(1.0 - VoH, 5);
}

vec3 SchlickRough_F(vec3 F0, float VoH, float roughness)
{
	return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - VoH, 5.0);
}

vec3 CookTorrance_F(vec3 F0, float VoH)
{
	vec3 sqrtF0 = sqrt(F0);
	vec3 n = (1 + sqrtF0) / (1.0 - sqrtF0);
	vec3 g = sqrt(n * n + VoH * VoH - 1.0);
	
	vec3 p1 = (g - VoH) / (g + VoH);
	p1 = p1 * p1 * 0.5;
	vec3 p2 = (VoH * (g + VoH) - 1.0) /  (VoH * (g - VoH) + 1.0);
	p2 = 1.0 + p2 * p2;
	
	return p1 * p2;
}

// BRDFs

vec3 CookTorrance_BRDF(float D, float G, vec3 F, float NoL, float NoV)
{
	vec3 p1 = D * G * F;
	float p2 = 4 * NoL * NoV;
	
	return p1 / p2;
}

// Preconvolution,   NEEDS TO BE MOVED

float RadicalInverse_VdC(uint bits) 
{
    bits = (bits << 16u) | (bits >> 16u);
    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);
    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);
    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);
    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);
    return float(bits) * 2.3283064365386963e-10; // / 0x100000000
}
// ----------------------------------------------------------------------------
vec2 Hammersley(uint i, uint N)
{
    return vec2(float(i)/float(N), RadicalInverse_VdC(i));
}  

vec3 ImportanceSampleGGX(vec2 Xi, vec3 N, float alpha)
{
    float phi = 2.0 * PI * Xi.x;
    float cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (alpha*alpha - 1.0) * Xi.y));
    float sinTheta = sqrt(1.0 - cosTheta*cosTheta);
	
    // from spherical coordinates to cartesian coordinates
    vec3 H;
    H.x = cos(phi) * sinTheta;
    H.y = sin(phi) * sinTheta;
    H.z = cosTheta;
	
    // from tangent-space vector to world-space sample vector
    vec3 up        = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);
    vec3 tangent   = normalize(cross(up, N));
    vec3 bitangent = cross(N, tangent);
	
    vec3 sampleVec = tangent * H.x + bitangent * H.y + N * H.z;
    return normalize(sampleVec);
}  

vec3 CubemapPreconvolution(int faceRes, samplerCube probe, float alpha, vec3 R)
{
    vec3 N = R;
    vec3 V = N;

    const uint SAMPLE_COUNT = 10u;//1024u;
    float totalWeight = 0.0;   
    vec3 prefilteredColor = vec3(0.0);     
    for(uint i = 0u; i < SAMPLE_COUNT; ++i)
    {
        vec2 Xi = Hammersley(i, SAMPLE_COUNT);
        vec3 H  = ImportanceSampleGGX(Xi, N, alpha);
        vec3 L  = normalize(2.0 * dot(V, H) * H - V);

        float NdotL = max(dot(N, L), 0.0);
        float NdotH = max(dot(N, H), 0.0);
        float HdotV = max(dot(H, V), 0.0);
		
		/*float D   = GGX_NDF(NdotH, alpha);
		float pdf = (D * NdotH / (4.0 * HdotV)) + 0.0001; 
		
		float saTexel  = 4.0 * PI / (6.0 * faceRes * faceRes);
		float saSample = 1.0 / (float(SAMPLE_COUNT) * pdf + 0.0001);
		
		float mipLevel = alpha == 0.0 ? 0.0 : 0.5 * log2(saSample / saTexel); */
		
        if(NdotL > 0.0)
        {
            prefilteredColor += texture(probe, L).rgb * NdotL;
            totalWeight      += NdotL;
        }
    }
    prefilteredColor = prefilteredColor / totalWeight;

    return prefilteredColor;
}